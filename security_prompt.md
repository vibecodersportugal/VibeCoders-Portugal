## ðŸ“‚ Prompt List for AI-Generated Code Security Analysis

### 1. General Security Assessment

- "Analyze this code and identify potential vulnerabilities, classifying them by severity."
- "Review this code and highlight any insecure or non-recommended practices."
- "Check if this code follows OWASP Top 10 recommendations and point out deviations."
- "Evaluate whether this code complies with Secure Coding principles."
- "Assess whether the code follows the principle of 'fail securely' â€” i.e., when an error occurs, no sensitive information is exposed."
- "Verify that all external inputs are handled securely, even if they seem trusted."
- "Review if the code avoids the use of insecure functions, deprecated libraries, or unsafe patterns."
- "Check for the presence of any hardcoded secrets (passwords, API keys, encryption keys)."
- "Evaluate the overall architecture to ensure separation of concerns, minimizing the blast radius of a potential breach."
- "Assess the risk of business logic vulnerabilities â€” flaws that could be exploited by manipulating the expected flow."
- "Review whether security-related configurations (e.g., CSP, CORS, SSL/TLS settings) are explicitly set and not left to defaults."
- "Identify code segments that could be abused for privilege escalation."
- "Check if logs generated by the application avoid storing sensitive information."
- "Analyze if error messages are generic and avoid exposing internal implementation details."
- "Review the code for potential supply chain risks, including the way dependencies are fetched and verified."
- "Verify that all environment-specific settings (e.g., production vs. development) are properly separated and cannot be accidentally exposed."
- "Assess whether adequate input and output encoding is applied where applicable."
- "Identify if there are any concurrency or race condition issues that could be exploited."
- "Evaluate if the code includes any unused or leftover debug code that could compromise security."

### 2. Input and Output Validation

- "Identify all parts of the code where user input is received and check if robust validation is applied."
- "Verify whether data sanitization is correctly performed before being used in commands, queries, or rendering."
- "Analyze if there are any Cross-Site Scripting (XSS) risks and how they could be exploited."

#### Detailed Security Checks

- Ensure **whitelisting** (allow lists) is used instead of blacklisting for input validation whenever possible.
- Check that **input length limits** are enforced to prevent buffer overflows and resource exhaustion.
- Verify that **input data types** are validated (e.g., numeric fields must reject alphabetic characters).
- Validate that file uploads have strict **MIME type** and **extension** checks, along with secure storage locations.
- Ensure **server-side validation** is implemented (never rely solely on client-side validation).
- Verify that **regular expressions** used for validation are not vulnerable to ReDoS (Regular Expression Denial of Service).
- Check that all user-provided data is **properly escaped or encoded** before inclusion in:
  - HTML (to prevent XSS)
  - JavaScript (to prevent DOM-based XSS)
  - SQL queries (to prevent SQL Injection)
  - OS commands (to prevent Command Injection)
  - LDAP queries (to prevent LDAP Injection)
  - XML (to prevent XML Injection / XXE)
- Confirm that JSON and XML parsers are configured securely (e.g., disabling external entity resolution).
- Verify that HTML sanitization libraries are up-to-date and configured to remove dangerous tags and attributes.
- Ensure that untrusted input is not concatenated directly into **URLs**, **redirects**, or **file paths** without proper validation.
- Check that API endpoints validate **query parameters**, **path variables**, and **request bodies** consistently.
- Validate that the application enforces a **content security policy (CSP)** to mitigate XSS from untrusted output.
- Ensure output encoding matches the output context (HTML, JSON, JavaScript, etc.).
- Review whether default framework output encoding is enabled and not bypassed.
- Verify that error messages do not include raw input values, especially when reflecting them back to the user.
- For AI-generated code: check if the model produced generic validation functions that may be too permissive.
- Identify any areas where user input is used to build code dynamically (dangerous in languages like Python, JavaScript, PHP).
- Verify if dynamic HTML generation is properly sandboxed when using templates or rendering engines.

### 3. Injection Vulnerabilities

- "Look for potential SQL Injection or NoSQL Injection points and suggest fixes."
- "Check if operating system commands are dynamically built from unvalidated input."
- "Analyze if there is a risk of Command Injection or LDAP Injection in this code."

#### Detailed Security Checks

- Verify that **parameterized queries** (prepared statements) are used for SQL/NoSQL interactions instead of string concatenation.
- Check if ORM (Object-Relational Mapping) queries are protected against injection through built-in escaping and parameter binding.
- Ensure stored procedures, if used, are free from dynamic SQL execution with untrusted inputs.
- Validate that all database query inputs undergo **server-side validation and sanitization**.
- Verify that **NoSQL databases** (e.g., MongoDB, CouchDB) do not directly interpolate user input into queries.
- Ensure **Command Injection** risks are mitigated by:
  - Avoiding direct shell/command execution where possible.
  - Using safe APIs instead of `exec()`, `system()`, `popen()`, or similar.
  - Sanitizing and validating all command arguments.
- Check for **LDAP Injection** by ensuring LDAP queries are parameterized and user input is escaped according to LDAP syntax rules.
- Identify potential **XML Injection** and **XXE (XML External Entity)** risks:
  - Disable external entity resolution in XML parsers.
  - Use secure XML parsing libraries and configurations.
- Validate against **XPath Injection** by using parameterized XPath queries and escaping user inputs.
- Check for **JSON Injection** vulnerabilities, especially when data is directly inserted into JSON responses without encoding.
- Ensure **Template Injection** risks are mitigated by using safe template engines and avoiding direct user input in templates.
- Review code for **Expression Language (EL) Injection** vulnerabilities in frameworks like Spring, Django, or JSF.
- Check if AI-generated code uses unsafe string concatenation in queries or commands, as this is a common vulnerability pattern in AI outputs.
- Verify that all **file path inputs** are validated to prevent Path Traversal attacks (e.g., `../../../etc/passwd`).
- Ensure that dynamic code evaluation functions (`eval`, `Function`, `exec`) are avoided or sandboxed when absolutely necessary.
- Confirm that escaping functions are appropriate for the injection context (SQL escaping != HTML escaping).
- Review if database user accounts used by the application have **minimal privileges** required for their tasks (principle of least privilege).
- Ensure proper **error handling** to prevent revealing query structures or internal commands in error messages.â€¨â€¨â€”â€¨### 4. Authentication and Session Management
- "Verify if the authentication implemented in this code is secure and if credentials are protected."
- "Check if session management is secure, including the use of Secure, HttpOnly, and SameSite cookies."
- "Identify risks of Session Fixation or session hijacking."

#### Detailed Security Checks

- Ensure that **multi-factor authentication (MFA)** is implemented for sensitive accounts (e.g., SMS, hardware tokens, authenticator apps).
- Verify that **password hashing** uses strong algorithms (e.g., bcrypt, Argon2, PBKDF2) with adequate work factors.
- Confirm that passwords are never stored in plain text or with reversible encryption.
- Ensure that password reset functionality:
  - Uses time-limited, single-use secure tokens.
  - Does not reveal whether an account exists.
  - Validates the requesterâ€™s identity before allowing reset.
- Check for **secure session creation** upon login, ensuring that session IDs are regenerated after authentication.
- Verify that session cookies:
  - Use the `Secure` flag to enforce HTTPS transmission.
  - Use the `HttpOnly` flag to prevent JavaScript access.
  - Use the `SameSite=Strict` or `Lax` attribute to mitigate CSRF.
- Ensure that session IDs are long, random, and unpredictable.
- Verify that sessions expire after a reasonable period of inactivity (e.g., 15â€“30 minutes for sensitive actions).
- Implement **absolute session timeouts** (maximum lifespan regardless of activity).
- Confirm that session termination on logout fully invalidates the server-side session and clears cookies.
- Check that concurrent logins are restricted or monitored for anomalies.
- Ensure that account lockout is enforced after a defined number of failed login attempts, with secure unlock procedures.
- Verify that authentication endpoints are protected against brute-force attacks (rate limiting, CAPTCHA, MFA challenge).
- Review **"Remember Me"** functionality for secure implementation (e.g., encrypted, time-limited persistent cookies).
- Check that API authentication uses secure token-based mechanisms (JWT, OAuth2) with short-lived tokens and refresh tokens.
- Ensure JWTs:
  - Use strong signing algorithms (e.g., RS256 or ES256, not HS256 with weak secrets).
  - Are validated for expiration (`exp` claim) and issued-at times (`iat`).
  - Do not store sensitive information in the payload unless encrypted.
- Validate that login and registration forms are always served over HTTPS.
- Confirm that authentication error messages do not reveal whether a username or email is valid.
- For AI-generated code, look for placeholder authentication logic or default credentials that may have been left in the code.
- Verify that administrative accounts have stricter authentication policies and enhanced monitoring.
- Ensure that **Single Sign-On (SSO)** implementations are securely configured and validated against protocol-specific attacks.

â€¨### 5. Access Control

- "Review whether access control is enforced consistently at the server side."
- "Check if role-based or attribute-based access control is implemented correctly."
- "Identify any endpoints or actions that could be accessed without proper authorization."

#### Detailed Security Checks

- Ensure that **authorization checks** are performed on the server side for every sensitive action or resource.
- Verify that access control is enforced **after authentication** and before returning any protected data.
- Confirm that **Role-Based Access Control (RBAC)** or **Attribute-Based Access Control (ABAC)** is implemented and roles are well-defined.
- Review whether sensitive administrative functions are restricted only to authorized administrative roles.
- Ensure that access control rules are **centralized** to prevent inconsistent enforcement across the application.
- Verify that **horizontal access control** (preventing one user from accessing another userâ€™s data) is properly implemented.
- Verify that **vertical access control** (preventing lower-privilege users from performing admin-level actions) is properly implemented.
- Check that **object-level permissions** are enforced, ensuring users can only access resources they own or are authorized for.
- Ensure that **Mass Assignment / Insecure Direct Object References (IDOR)** vulnerabilities are prevented by:
  - Not exposing direct identifiers in URLs or payloads.
  - Validating ownership or permissions before data access.
- Verify that hidden form fields or client-side parameters are **not trusted** for access control decisions.
- Ensure **default access** is deny-all, explicitly granting permissions where needed.
- Confirm that API endpoints have proper authorization checks, regardless of whether they are exposed publicly or internally.
- Check for **function-level authorization**, ensuring endpoints cannot be called by unauthorized roles via crafted requests.
- Review file and resource access to ensure that:
  - Sensitive files are not stored in publicly accessible locations.
  - Directory listings are disabled.
- Verify that access control checks cannot be bypassed by modifying request parameters, headers, or payloads.
- Ensure that **multi-tenant applications** properly isolate data between tenants.
- Check that administrative APIs and dashboards are:
  - Restricted to specific IP ranges when possible.
  - Protected by MFA in addition to standard authentication.
- Validate that error messages for unauthorized actions do not leak details about the access control rules.
- For AI-generated code:
  - Look for overly simplistic role checks such as `if (user.role == 'admin')` without considering privilege escalation risks.
  - Check for hardcoded roles or privilege flags in the code.
  - Identify if generated code accidentally exposes sensitive endpoints due to permissive route definitions.
- Ensure logging is in place for all access control violations to support security monitoring.

### 6. Data Protection

- "Verify if sensitive data is encrypted in transit and at rest."
- "Check if cryptographic algorithms and key management practices are secure."
- "Identify any potential data leaks through logs, error messages, or insecure storage."

#### Detailed Security Checks

- Ensure that **all sensitive data in transit** is transmitted only over TLS 1.2+ (preferably TLS 1.3), with strong cipher suites.
- Verify that **HSTS (HTTP Strict Transport Security)** is enabled to enforce HTTPS.
- Confirm that **sensitive data at rest** (e.g., personal information, passwords, tokens, financial data) is encrypted using strong algorithms such as AES-256-GCM.
- Ensure that **encryption keys** are:
  - Stored in secure key management systems (e.g., AWS KMS, HashiCorp Vault).
  - Rotated regularly.
  - Never hardcoded into the source code or configuration files.
- Verify that **hashing** (with salts) is used for non-reversible data like passwords, rather than encryption.
- Ensure **API keys, tokens, and credentials** are stored securely (e.g., environment variables, secrets vaults) and not exposed in the codebase or version control history.
- Confirm that data is **masked or tokenized** where full values are not necessary for processing.
- Review **log files** to ensure they do not contain sensitive information such as passwords, credit card numbers, session IDs, or personal identifiers.
- Check that **debug mode** is disabled in production to avoid exposing stack traces with sensitive details.
- Ensure that **backups** of sensitive data are encrypted and stored securely, with strict access controls.
- Verify that **data retention policies** are implemented, ensuring sensitive data is deleted when no longer needed.
- Confirm that **temporary files** containing sensitive data are securely wiped after use.
- Ensure **database encryption** is enabled for data at rest (e.g., Transparent Data Encryption for SQL databases).
- Check that sensitive data is not exposed through:
  - URL query strings.
  - Browser storage (localStorage, sessionStorage) unless encrypted and short-lived.
  - Insecure cookies without encryption or `HttpOnly`.
- Verify **CORS policies** prevent unauthorized domains from accessing sensitive API data.
- Review **third-party integrations** to ensure they use secure channels and do not introduce data leakage risks.
- For AI-generated code:
  - Look for hardcoded secrets or test credentials.
  - Identify insecure default configurations that may disable encryption.
  - Check for accidental logging of entire request/response bodies containing sensitive data.
- Validate that **data exports** (e.g., CSV, PDF) are protected from unauthorized download or access.
- Ensure that sensitive data is **pseudonymized or anonymized** when used for analytics, testing, or AI model training.
- Verify compliance with relevant privacy regulations (e.g., RGPD, HIPAA, PCI-DSS) for handling and storing sensitive information.

### 7. Input Validation & Output Encoding

- "Check if all user inputs are validated and sanitized before processing."
- "Verify that output is properly encoded to prevent XSS and other injection attacks."
- "Identify any unsafe direct use of user input in SQL queries, file paths, or system commands."

#### Detailed Security Checks

- Ensure **input validation** is performed on the server side (never rely solely on client-side validation).
- Use **whitelisting** (allowing only expected formats) instead of blacklisting to validate inputs.
- Define and enforce **strict data formats** for:
  - Text fields (length, allowed characters).
  - Numbers (range checks).
  - Dates and timestamps.
  - File uploads (type, size, and content verification).
- Validate and sanitize **all inputs**, including:
  - Query parameters.
  - POST bodies.
  - Headers.
  - Cookies.
  - JSON/XML payloads.
- Prevent **injection attacks** by:
  - Using prepared statements or ORM frameworks for database queries.
  - Escaping special characters in commands and queries.
  - Avoiding dynamic query building from user input.
- Ensure **output encoding** based on context:
  - HTML encoding for HTML content.
  - JavaScript escaping for inline scripts.
  - CSS escaping for inline styles.
  - URL encoding for query parameters.
- Prevent **Cross-Site Scripting (XSS)** by:
  - Encoding all untrusted data before rendering it in the browser.
  - Applying Content Security Policy (CSP) to restrict script sources.
  - Avoiding inline JavaScript and dynamically created HTML from user input.
- For **file uploads**:
  - Validate MIME type and file extension.
  - Scan files for malware.
  - Store uploaded files outside the web root and serve them via secure endpoints.
- Prevent **path traversal attacks** by:
  - Normalizing file paths.
  - Restricting access to specific directories.
- Validate **API request data** against strict schemas (e.g., JSON Schema, OpenAPI validation).
- For **XML inputs**:
  - Disable external entity processing (XXE prevention).
  - Limit XML size and complexity to prevent denial of service.
- Ensure **numeric inputs** are checked for overflows and type constraints.
- Verify **rich text editors** are configured to allow only safe HTML tags and attributes.
- For AI-generated code:
  - Look for direct insertion of user input into SQL queries, HTML templates, or shell commands.
  - Check if validation logic is overly permissive or missing entirely.
  - Detect placeholder validation functions left unimplemented.
- Ensure error messages do not reflect raw user input back to the client without encoding.
- Test with **fuzzing** tools to ensure unexpected input does not cause crashes or leaks.

â€¨### 8. Logging & Monitoring

- "Verify if security-relevant events are logged with sufficient detail."
- "Check if logs are protected against tampering and unauthorized access."
- "Ensure that monitoring is in place to detect suspicious activities."

#### Detailed Security Checks

- Log **security-relevant events**, including:
  - Successful and failed login attempts.
  - Privilege escalation actions.
  - Password and profile changes.
  - Access to sensitive data.
  - Creation, modification, and deletion of critical resources.
  - Changes to security configurations.
  - Critical API calls and admin actions.
- Ensure logs include:
  - Date and time with **UTC timestamp**.
  - Unique session or request identifier.
  - User or system ID involved.
  - Origin of the request (IP address, user-agent).
- Protect **logs from tampering**:
  - Store logs in centralized, append-only systems (e.g., ELK Stack, Splunk).
  - Use digital signatures or hashing to ensure integrity.
  - Restrict log access to authorized personnel only.
- Avoid logging **sensitive data in plain text**, such as:
  - Passwords.
  - Session tokens.
  - Credit card numbers.
  - Personal data subject to GDPR or equivalent regulations.
- Implement **log retention policies** according to compliance and business needs.
- Configure **automatic alerts** for critical events:
  - Multiple consecutive authentication failures.
  - Unusual spikes in traffic or API calls.
  - Attempts to exploit known vulnerabilities.
- Integrate logs with a **SIEM** (Security Information and Event Management) for correlation and real-time threat detection.
- Use **File Integrity Monitoring (FIM)** to detect unauthorized file changes.
- Conduct **periodic log reviews** to identify anomalies or suspicious behavior.
- Maintain **real-time security dashboards** for ongoing monitoring.
- Ensure logging and monitoring are **enabled across all environments** (production, staging, development) with appropriate verbosity.
- Implement **anomaly detection** using static rules or machine learning.
- For AI-generated code:
  - Check that generated code does not log sensitive data excessively.
  - Ensure debug logs are disabled in production builds.
  - Detect instances where large data objects are logged without sanitization.
- Test logging systems by simulating incidents to verify that:
  - Events are captured accurately.
  - Alerts are triggered promptly.
  - The security team receives actionable notifications.

### 9. Dependency & Supply Chain Security

- "Verify that all dependencies are regularly updated and free from known vulnerabilities."
- "Check if third-party libraries and APIs are from trusted sources."
- "Identify any unused or unnecessary dependencies that may increase the attack surface."

#### Detailed Security Checks

- Use **dependency vulnerability scanning tools**, such as:
  - `npm audit` for Node.js.
  - `pip-audit` or `safety` for Python.
  - `OWASP Dependency-Check`.
  - Integrate automated scanners into the CI/CD pipeline.
- Monitor for vulnerabilities using **CVE databases** (Common Vulnerabilities and Exposures) and feeds like NVD.
- Ensure **all dependencies** are sourced from official repositories and maintained by trusted teams.
- Avoid **abandoned dependencies** or those with a history of unresolved security issues.
- Implement **version pinning** to prevent untested updates from introducing malicious code.
- Verify the **integrity of packages** (checksums, digital signatures) before installation.
- Audit **transitive dependencies** (dependencies of dependencies), which are often targeted by attackers.
- Remove **unused or outdated libraries** to reduce the attack surface.
- Use **sandboxing** or isolation techniques when executing third-party code.
- Monitor for **unexpected behavior** after library updates.
- Apply **security controls for external APIs**:
  - Strong authentication.
  - Rate limiting.
  - Data validation and sanitization.
- Avoid dependencies from unknown origins or **typosquatting** packages (malicious lookalikes).
- Maintain **allowlists** of approved libraries and block unverified sources.
- For internal repositories:
  - Conduct periodic audits.
  - Use package management solutions like **Artifactory** or **Nexus**.
- Set up **real-time alerts** for newly discovered vulnerabilities in dependencies.
- For AI-generated code:
  - Review imports to ensure no insecure or unnecessary packages are included.
  - Identify outdated libraries suggested by the AI.
  - Validate that example code from AI does not pull from malicious repositories.
- Include **supply chain security tests** in the development lifecycle.
- Validate digital signatures of code and dependencies before deploying to production.
- Maintain an **incident response plan** in case a critical dependency is compromised.

â€¨### 10. Error Handling & Security Misconfigurations

- "Ensure error messages do not reveal sensitive system information."
- "Check for insecure default configurations and remove them."
- "Verify that application and server settings follow the principle of least privilege."

#### Detailed Security Checks

- **Error Handling:**
  - Ensure **user-facing error messages** are generic and do not disclose:
    - Framework versions.
    - Server details.
    - Database names or query structures.
    - Internal file paths.
  - Keep **detailed error logs** only in secured internal systems.
  - Disable **stack traces** in production environments.
  - Avoid exposing **debug endpoints** or development tools to public networks.
  - Validate that API error responses do not reveal sensitive schema details or backend technologies.
  - Implement **custom error pages** to replace default server error pages.
  
- **Security Misconfigurations:**
  - Disable all **unused services, ports, and modules**.
  - Remove **default accounts** or change their credentials immediately.
  - Enforce **least privilege** for application and database accounts.
  - Use **secure headers**:
    - `Content-Security-Policy`
    - `X-Frame-Options: DENY`
    - `Strict-Transport-Security`
    - `X-Content-Type-Options: nosniff`
  - Disable **directory listing** on web servers.
  - Configure **secure SSL/TLS settings**:
    - Disable outdated protocols (SSLv2, SSLv3, TLS 1.0, TLS 1.1).
    - Use strong cipher suites.
    - Enable certificate pinning where applicable.
  - Regularly scan for **open ports** and misconfigured firewalls.
  - Ensure **configuration files** are not stored in public directories.
  - Protect `.env` and other environment variable files from public access.
  - Validate that database **remote access** is disabled unless strictly necessary.
  - Remove or disable **test and staging environments** from production networks.
  - For containers:
    - Run as a non-root user.
    - Limit container capabilities.
    - Use minimal base images.
    - Scan container images for vulnerabilities.
  - For cloud environments:
    - Validate security group rules.
    - Restrict public access to storage buckets.
    - Enable encryption at rest and in transit.

- **AI-Generated Code Considerations:**
  - Check that AI-generated code does not leave debug flags enabled.
  - Review for hardcoded secrets or test credentials.
  - Ensure that code snippets do not use insecure default configurations from outdated tutorials.
  - Validate any automatically generated Dockerfiles, Kubernetes manifests, or CI/CD configs for excessive permissions or insecure settings.
  
- **Testing & Verification:**
  - Perform **configuration reviews** during code audits.
  - Use automated tools such as:
    - **Lynis** (for Unix systems).
    - **OpenVAS** or **Nessus** for vulnerability scanning.
    - **ScoutSuite** or **Prowler** for cloud security audits.
  - Include misconfiguration checks in continuous security testing pipelines.

